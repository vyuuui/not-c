DefinitelyNotAsm IR description:
Low-level IR to be given to the final code generator
- linear memory layout (stack + readonly global constants)
- all types are matched in opcodes (no implicit casting)
- explicit casts
- emits compiler-library calls for some tasks (global-constant array templates to local arrays, int/float casting)
- non-primitive constants must be declared explicitly outside of function
- primitive constants allowed in immediate form

--------------------------------
IR format:
<IR file> = <subroutine>*
            <global constants>*
<subroutine> = <subroutine declaration>
               <frame description>
               <subroutine body>
               <subroutine terminator>
<subroutine declaration> = 'beginsubroutine' name
<frame description> = 'beginframeinfo'
                      <frame vars list>
                      'endframeinfo'
<frame vars list> = ('in' | 'local' | 'temp') name type (repeats)
<subroutine terminator> = 'endsubroutine'
<subroutine body> = <instruction>*
<global constants> = 'beginarray' name type
                     comma separated values
                     'endarray'
types: int8 int16 int32 int64 float
type form: 'ptr'? ('arr[' count ']')? typename

note: if both 'ptr' and 'arr' are specified, it is an array of pointer type 
      directly referencing a variable with type 'arr' (without '&') will always refer to the first element
      to properly index an array, any "arr" variable must have its address placed into a temp/local to then be dereferenced

--------------------------------
Instruction format (fills for <instruction>)
Operand forms:
    <destop> = <variable> | <memref>
    <srcop> = &?<variable> | <memref> | <constant>
    <variable> = <varname>
    <memref> = [&?<varname> (+ offset)?]  // note: offset should be treated as a raw byte offset!
    <constant> = integral | floating | global-constant | label

opcode type specifier:
    any opcode that has the [type] attribute can optionally specify what type the operands will be treated as
    if omitted, the instruction will default to the type of its destination as its net type
    e.g. let t3 : int8, t4 : float, t5 : int64, t6 : ptr int32
    mov t3 t4  -> typed as int8
    mov t4 t5  -> typed as float
    mov float t3 t4 -> typed as float

Operand type rules:
    - Constants are typed as their given types
    - Instructions which mismatch the constant type from the other operand types
      should just cast the constant to the type specifier of the instruction
    - Pointer types referenced within a <memref> unwrap the pointer specifier
      e.g. given that t1 : ptr int8, t2 : int8
           mov [t1] t2
           should treat [t1] as type int8, not ptr int8, thus the whole mov is typed as int8

opcodes:
    copying:
        mov [type] <destop> <srcop>
    integral math:
        add [type] <destop> <srcop> <srcop>
        sub [type] <destop> <srcop> <srcop>
        mul [type] <destop> <srcop> <srcop>
        div [type] <destop> <srcop> <srcop>
        mod [type] <destop> <srcop> <srcop>
    control flow:
        cmp [type] <srcop> <srcop>
        jmp label
        jc label  // (c=e | ne | gt | lt | ge | le)
    function control flow:
        param <srcop>
        label <name>
        call label <destop>  // label must be a subroutine
        return <srcop>
        return  // for void return type
    compiler-library:
        arraycopy <destop> <srcop> size  // size is specified in bytes
        inttofloat <destop> <srcop>
        floattoint <destop> <srcop>
